## 前言
----------------------------------------
我的天，已经是七月六日了，我这几天好像什么都没有干啊。  
因为不可抗的因素回家了。  
前几天看了订单支付部分，但是太潦草了，今天必须重新来过。

----------------------------------------

## 日程
----------------------------------------
把第9天的内容做完了，有个需要调百度地图接口，因为有审核卡着要迟一点。

----------------------------------------

## 学习内容
----------------------------------------
### 省流：
1. spring task
2. WebSocket
3. Apache POI

### 1. Spring Task
**定时任务框架**

注：`spring-task`的依赖已经包含在`starter`中了。  
如果要使用，需要在启动类上加上`@EnableScheduling`注解。

通过一个简单例子：
```java
@Component
public class MyTask {
    @Scheduled(cron = "0 * * * * ?")
    public void processTimeout() {
        // todo something
    }
}
```

`task`通过`cron`表达式来控制定时任务的触发时机。

**Cron 表达式**是一个字符串，用于定义任务触发的时间规则。它由 **6 或 7 个域** 组成，各域之间用 **空格** 分隔，每个域代表不同的时间单位。

| 域   | 含义       |
|------|------------|
| 秒   | 0 - 59     |
| 分钟 | 0 - 59     |
| 小时 | 0 - 23     |
| 日   | 1 - 31     |
| 月   | 1 - 12     |
| 周   | 0 - 6      |
| 年   | 可选       |

示例：
- **`0 0 9 12 10 ? 2022`**  
  表示：**2022 年 10 月 12 日上午 9 点整**  
  （秒=0，分钟=0，小时=9，日=12，月=10，周=`?`不指定，年=2022）

**注意事项**
1. **周和日通常冲突**：若指定了具体日（如`12`），周通常设为 `?`。
2. **年可选**：可省略第7个域，表示每年都触发。

Cron手写起来会比较抽象，但是现在有很多在线的生成工具：[Cron - 在线Cron表达式生成器](https://cron.ciding.cc/)

### 2. WebSocket
**基于TCP的网络协议，实现客户端与服务端的持久性双向通信。**

**spring-websocket依赖**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

**创建WebSocket服务**
```java
@Component
@ServerEndpoint("/ws/{sid}")
public class WebSocketServer {
    // ...
}
```

前端代码需要创建与`@ServerEndpoint("/ws/{sid}")`对应的连接点：
```javascript
<script type="text/javascript">
    var websocket = null;
    var clientId = Math.random().toString(36).substr(2);

    // 判断当前浏览器是否支持WebSocket
    if('WebSocket' in window){
        // 连接WebSocket节点
        websocket = new WebSocket("ws://localhost:8080/ws/"+clientId);
    }
    else{
        alert('Not support websocket')
    }

    // 连接发生错误的回调方法
    websocket.onerror = function(){
        setMessageInnerHTML("error");
    };

    // 连接成功建立的回调方法
    websocket.onopen = function(){
        setMessageInnerHTML("连接成功");
    }

    // 接收到消息的回调方法
    websocket.onmessage = function(event){
        setMessageInnerHTML(event.data);
    }

    // 连接关闭的回调方法
    websocket.onclose = function(){
        setMessageInnerHTML("close");
    }

    // 监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
    window.onbeforeunload = function(){
        websocket.close();
    }

    // 将消息显示在网页上
    function setMessageInnerHTML(innerHTML){
        document.getElementById('message').innerHTML += innerHTML + '<br/>';
    }

    // 发送消息
    function send(){
        var message = document.getElementById('text').value;
        websocket.send(message);
    }
    
    // 关闭连接
    function closeWebSocket() {
        websocket.close();
    }
</script>
```

**创建一个会话对象**
```java
private static Map<String, Session> sessionMap = new HashMap();
```

在连接成功时，将会话加入到对象中：
```java
@OnOpen
public void onOpen(Session session, @PathParam("sid") String sid) {
    System.out.println("客户端：" + sid + "建立连接");
    sessionMap.put(sid, session);
}
```

同理，关闭时，移除会话对象：
```java
@OnClose
public void onClose(@PathParam("sid") String sid) {
    System.out.println("连接断开:" + sid);
    sessionMap.remove(sid);
}
```

收到客户端消息时的回调：
```java
@OnMessage
public void onMessage(String message, @PathParam("sid") String sid) {
    System.out.println("收到来自客户端：" + sid + "的信息:" + message);
}
```

主动向客户端发送消息，因为遍历了所有的会话对象，所以是群发：
```java
public void sendToAllClient(String message) {
    Collection<Session> sessions = sessionMap.values();
    for (Session session : sessions) {
        try {
            // 服务器向客户端发送消息
            session.getBasicRemote().sendText(message);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

单发则需要根据`clientId`获取键值：
```java
Session session = sessionMap.get(clientId);
```

### 3. Apache POI
**用于处理Miscrosoft Office文件的工具**

**maven依赖**
```xml
<!-- poi -->
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
</dependency>
```

**创建一个XSSF对象**
```java
XSSFWorkbook workbook = new XSSFWorkbook();
```

也可以从输入流中读取：
```java
XSSFWorkbook workbook = new XSSFWorkbook(in);
```

接着读取一个标签页，这与实际的excel操作类似：
```java
XSSFSheet sheet = workbook.getSheet("Sheet1");
```

获取行/列对象（0起始）：
```java
XSSFRow row = sheet.getRow(0);
XSSFCell cell = row.getCell(0);
```

设置列内容：
```java
row.getCell(1).setCellValue(data.toString());
```

将内容写出到输出流：
```java
workbook.write(out);
```

注：`XSSF`与流对象类似，需要关闭资源：
```java
workbook.close();
```

----------------------------------------