# MyBatis处理自定义枚举

在开发中，我们常常需要处理自定义枚举类型，但MyBatis默认无法自动处理字段到自定义枚举的转换，需要手动配置一个处理器。本文将详细介绍如何实现这一功能，并提供一些优化方案。

## 1. 实现方法

### 1.1 继承`BaseTypeHandler`

首先，我们需要继承MyBatis的基类处理器`BaseTypeHandler`，并重写其中的方法。这些方法包括：

- 将一个Java对象的非`null`值设置到`PreparedStatement`的指定参数占位符（`?`）上
- 处理返回结果集，根据列名和列序号查找
- 处理存储过程

假设我们有一个枚举类`Gender`：

```java
public enum Gender {
    MALE("M");
    private final String code;
    public String getCode() { return code; }
}
```

我们需要将`Gender`对象转换为字符串`M`，并传递给数据库。为此，我们给父类绑定`Gender`作为泛型`BaseTypeHandler<Gender>`，并重写`setNonNullParameter`方法：

```java
@Override
public void setNonNullParameter(PreparedStatement ps, int i, Gender parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter.getCode());
}
```

接下来，我们需要处理返回结果集。这包括根据列名和列序号查找：

```java
@Override
public Object getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return null;
}

@Override
public Object getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
}
```

最后，处理存储过程，方式与返回结果集相同：

```java
@Override
public E getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    Object code = cs.getObject(columnIndex);
    return code == null ? null : getEnumByCode(code);
}
```

为了让MyBatis知道有这么一个处理器，还需要在配置文件中写入：

```yaml
mybatis:
  type-handlers-package:
    com.kat.common.handler.GenericEnumTypeHandler # 枚举类型转换处理器
```

我们还需要为处理器编写一个无参构造函数，这是Spring的IoC容器机制决定的：

```java
public GenericEnumTypeHandler() {}
```

### 1.2 处理器的创建时机

假设我们有以下Mapper方法：

```java
@Select("SELECT * FROM user WHERE gender = #{gender}")
List<User> findByGender(Gender gender);
```

当第一次处理`gender`类型时，MyBatis会：

1. 发现参数类型是`Gender`
2. 查找对应的类型处理器
3. 创建`GenericEnumTypeHandler<Gender>`实例并初始化
4. 后续对该类型的处理都使用这个实例

### 1.3 泛用化

为了避免重复写多个处理器，我们可以先定义一个枚举基类和对应的接口：

```java
public interface BaseEnum<T> {
    /**
     * 获取枚举值
     */
    T getCode();
}

@Getter
public abstract class BaseEnumImpl<T> implements BaseEnum<T> {
    private final T code;
    private final String description;

    /**
     * 根据代码值获取枚举
     *
     * @param code 代码值
     * @param values 枚举的所有值
     * @param defaultEnum 默认枚举值
     * @param <E> 枚举类型
     * @return 对应的枚举实例
     */
    protected static <E extends BaseEnum<?>> E getByCode(Object code, E[] values, E defaultEnum) {
        if (code == null) {
            return defaultEnum;
        }

        for (E enumValue : values) {
            if (code.equals(enumValue.getCode())) {
                return enumValue;
            }
        }
        return defaultEnum;
    }
}
```

然后，由枚举类实现接口，并调用静态实现类的方法：

```java
@Getter
public enum Gender implements BaseEnum<String> {
    MALE("m", "男"),
    FEMALE("f", "女"),
    OTHER("o", "其他"),
    UNKNOWN("u", "未知");

    private final String code;
    private final String description;

    /**
     * 根据代码获取枚举
     */
    public static Gender getByCode(String code) {
        return BaseEnumImpl.getByCode(code, values(), UNKNOWN);
    }
}
```

在处理器中定义该泛型：

```java
public class GenericEnumTypeHandler<E extends Enum<E> & BaseEnum<?>> extends BaseTypeHandler<E> {
    private final Class<E> type;
    private final E[] enums;

    public GenericEnumTypeHandler(Class<E> type) {
        if (type == null) {
            throw new IllegalArgumentException("type不能为空");
        }
        this.type = type;
        this.enums = type.getEnumConstants();
        if (this.enums == null) {
            throw new IllegalArgumentException(type.getSimpleName() + "不是一个枚举类型");
        }
    }
}
```

### 1.4 泛型擦除带来的问题

Java的泛型在编译后会被擦除具体类型信息，只保留原始类型（Raw Type）。例如：

```java
GenericEnumTypeHandler<GenderEnum> handler = new GenericEnumTypeHandler<>(GenderEnum.class);
```

编译后变为：

```java
GenericEnumTypeHandler handler = new GenericEnumTypeHandler(GenderEnum.class);
```

这导致MyBatis无法知道`E`具体应该是什么枚举类型。因此，我们需要在处理器上主动标注：

```java
@MappedTypes(Gender.class)
```
这就导致了我们无法实现预期中想要的"偷懒"效果。


### 1.5 终极方案：MyBatis-Plus

MyBatis-Plus提供了一个超级简便的解决方法。只需要在希望作为表单字段的变量上加上注解即可：

```java
@EnumValue
private final String code;
```

Mapper配置如下：

```yaml
mybatis-plus: # 原来的mybatis配置需要改为plus
    configuration:
        # 将默认的枚举处理器指定为 MybatisEnumTypeHandler
        default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
```

### 1.6 序列化与反序列化

最后，我们需要解决数据接收和发送的问题。使用Jackson的注解即可：

```java
/**
 * 指定序列化值
 */
@JsonValue
public String getCode() {
    return this.code;
}

/**
 * 反序列化
 */
@JsonCreator
public static Gender getByCode(String code) {
    return EnumUtil.getByCode(Gender.class, code, UNKNOWN);
}
```
