

按 URL 路径控制
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/public/**").permitAll()       // 公开访问
    .requestMatchers("/user/**").hasRole("USER")     // 需 USER 角色
    .requestMatchers("/admin/**").hasRole("ADMIN")   // 需 ADMIN 角色
    .anyRequest().authenticated()                    // 其他请求需登录
);

按 HTTP 方法控制
http.authorizeHttpRequests(auth -> auth
    .requestMatchers(HttpMethod.GET, "/api/read").permitAll()   // 允许 GET
    .requestMatchers(HttpMethod.POST, "/api/write").hasRole("EDITOR")  // 需 EDITOR 角色
);

```mermaid
graph TD
    A[客户端请求] --> B[过滤器链]
    B --> C[Spring Security过滤器]
    C --> D[其他过滤器]
    D --> E[拦截器链]
    E --> F[Spring Security拦截器]
    F --> G[其他拦截器]
    G --> H[Controller]
    H --> I[业务逻辑处理]
    I --> J[异常处理器]
    J --> K[响应客户端]
过滤器属于Servlet容器，其中的异常无法被异常处理器捕获

SecurityContext持久化：Spring Security默认会将认证信息存储在SecurityContextHolder中，而SecurityContextHolder默认使用ThreadLocal存储。但在Web应用中，通常会有SecurityContextPersistenceFilter将SecurityContext存储在Session中，以便在多次请求间保持登录状态。

Session缓存认证：一旦用户成功认证，认证信息会被存储在HttpSession中。后续请求会直接从Session中获取认证信息，而不会每次都执行JWT验证。






用户登录 -> [前端] 发送登录请求 -> [后端] 验证成功，返回用户信息和权限列表
                                                               |
                                                               V
[前端] 收到权限列表 -> [前端] 拿权限列表去筛选 `dynamicRoutes` -> [前端] 生成该用户可访问的路由表
                                                               |
                                                               V
[前端] 使用 `router.addRoute()` 将可访问的路由添加到路由实例中 -> [前端] 用户可以访问授权页面


请注意最外层的双引号。这表示您在 Pinia store 中存储的 permissionRoutes 不是一个真正的 JavaScript 数组，而是一个包含了数组内容的 JSON 字符串。

这是为什么呢？
这通常是由于使用了 Pinia 的持久化插件（如 pinia-plugin-persistedstate）但没有正确配置序列化导致的。

插件在保存状态到 localStorage 时，会使用 JSON.stringify() 将您的路由数组转换成字符串。
当您刷新页面，插件从 localStorage 读取这个字符串时，它没有成功地用 JSON.parse() 将其解析回 JavaScript 对象/数组。
因此，permissionStore.permissionRoutes 的值就成了那个字符串本身。

persist: {
        storage: localStorage,
        serializer: {
            serialize: JSON.stringify,
            deserialize: parse,
        },
    },

router.addRoute() 的职责：是让这些路由变得可访问，让浏览器地址栏输入 URL 时能正确匹配到组件。它的核心是“功能性”。
permissionStore.permissionRoutes 的职责：是为UI（菜单组件）提供一个结构化、纯粹的数据模型，方便渲染。它的核心是“展示性”。



直接使用 `onclick` **不会**触发 Vue 的响应式更新机制（包括 `computed` 属性的重新计算），并且很可能会导致程序无法按预期工作。

这是一个在 Vue 开发中非常重要的概念，下面是详细解释：

### 为什么 `onclick` 不行？

1.  **执行上下文（Scope）不同**
    *   **`onclick="profileVisible = true"`**: 这是一个原生的 HTML 事件属性。当它被触发时，浏览器会尝试在**全局作用域**（即 `window` 对象）下执行这句 JavaScript 代码。它会寻找一个名为 `window.profileVisible` 的变量并将其设置为 `true`。它完全不知道 Vue 组件实例的存在，更不知道你定义在组件 `data` 中的那个 `profileVisible`。
    *   **`@click="profileVisible = true"`**: 这是 Vue 的事件绑定指令（`v-on:click` 的缩写）。Vue 在编译模板时，会解析这个指令。当点击事件发生时，Vue 会在**当前组件实例的上下文**中执行这句代码。这等同于在组件的某个方法中执行 `this.profileVisible = true`。

2.  **Vue 的响应式系统**
    *   Vue 的核心是其响应式系统。你在 `data` 中声明的属性（如 `profileVisible`）会被 Vue "代理"（Proxy）或 "劫持"（Object.defineProperty）。
    *   当你通过**组件实例**去修改这个属性时（例如 `this.profileVisible = true`），Vue 的响应式系统能够侦测到这个变化。
    *   侦测到变化后，Vue 会通知所有依赖这个数据的地方进行更新，比如重新渲染模板（`v-if="profileVisible"`）、重新计算 `computed` 属性等。
    *   使用 `onclick` 时，你操作的是一个完全独立于 Vue 响应式系统之外的（可能是全局的）变量，因此 Vue 无法侦测到任何变化，界面自然也不会更新。

### 正确的写法

在 Vue 中，处理事件必须使用 Vue 的指令。

**写法一：直接在模板中修改** (适用于简单逻辑)

```vue
<el-dropdown-item @click="profileVisible = true">
  个人中心
</el-dropdown-item>
```

**写法二：调用一个方法** (推荐，更清晰，易于维护和扩展)

```vue
<template>
  <el-dropdown-item @click="handleShowProfile">
    个人中心
  </el-dropdown-item>
</template>

<script>
export default {
  data() {
    return {
      profileVisible: false
    };
  },
  methods: {
    handleShowProfile() {
      // 在这里可以添加更多逻辑，比如打日志、发送请求等
      this.profileVisible = true;
    }
  }
}
</script>
```

### 总结对比

| 特性 | `@click` (Vue 指令) | `onclick` (原生 HTML 属性) |
| :--- | :--- | :--- |
| **执行上下文** | **Vue 组件实例** (`this`) | **全局作用域** (`window`) |
| **响应式** | **能触发** Vue 的响应式更新 | **不能触发** Vue 的响应式更新 |
| **数据访问** | 可以访问 `data`, `props`, `computed` 等 | 只能访问全局变量 |
| **方法调用** | 可以调用 `methods` 中定义的方法 | 只能调用全局函数 |
| **推荐用法** | **在 Vue 项目中必须使用** | **在 Vue 项目中应避免使用** |

**结论：** 在 Vue 项目中，**始终**应该使用 Vue 的事件处理指令（如 `@click`, `@input`, `@submit` 等）来处理 DOM 事件，以确保能够完全利用 Vue 强大的响应式系统和组件化能力。