

按 URL 路径控制
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/public/**").permitAll()       // 公开访问
    .requestMatchers("/user/**").hasRole("USER")     // 需 USER 角色
    .requestMatchers("/admin/**").hasRole("ADMIN")   // 需 ADMIN 角色
    .anyRequest().authenticated()                    // 其他请求需登录
);

按 HTTP 方法控制
http.authorizeHttpRequests(auth -> auth
    .requestMatchers(HttpMethod.GET, "/api/read").permitAll()   // 允许 GET
    .requestMatchers(HttpMethod.POST, "/api/write").hasRole("EDITOR")  // 需 EDITOR 角色
);

```mermaid
graph TD
    A[客户端请求] --> B[过滤器链]
    B --> C[Spring Security过滤器]
    C --> D[其他过滤器]
    D --> E[拦截器链]
    E --> F[Spring Security拦截器]
    F --> G[其他拦截器]
    G --> H[Controller]
    H --> I[业务逻辑处理]
    I --> J[异常处理器]
    J --> K[响应客户端]
过滤器属于Servlet容器，其中的异常无法被异常处理器捕获

SecurityContext持久化：Spring Security默认会将认证信息存储在SecurityContextHolder中，而SecurityContextHolder默认使用ThreadLocal存储。但在Web应用中，通常会有SecurityContextPersistenceFilter将SecurityContext存储在Session中，以便在多次请求间保持登录状态。

Session缓存认证：一旦用户成功认证，认证信息会被存储在HttpSession中。后续请求会直接从Session中获取认证信息，而不会每次都执行JWT验证。

------------------------------------


queryParams.value = { pageNum: 1, pageSize: 10}
queryParams.value = AllPages;
上面的能触发重置，下面的不行，有点抽象了

等价{...AllPages}

const queryParams = ref<SysPermissionQuery>(AllPages);

 <el-form-item label="创建时间">
    <el-date-picker v-model="queryParams.createdAt" type="date" placeholder="起始日期" clearable/>
  </el-form-item>

不抽象，你把顺序搞反了——
“上面那行能重置”并不是因为它写了 { pageNum: 1, pageSize: 10 }，而是因为你之前已经补过字段，
queryParams 里 早就存在 createdAt / updatedAt 这两个响应式属性；
这时再整体赋一个新对象，Vue 的 proxy 会保留引用关系，DatePicker 的 v-model 瞬间拿到 undefined，于是触发清空。
而当你换成：
TypeScript
复制

queryParams.value = { ...AllPages };

AllPages 本身没有 createdAt / updatedAt，
展开后得到的新对象也不存在这两个字段，
v-model 绑定的路径 直接断了（变成访问一个非响应式的、根本不存在的属性），
DatePicker 内部监听不到“从有到无”的变动，于是面板里依旧显示旧值，看起来就像“没重置”。
一句话总结

    只要 初始声明（或之前某次赋值）里出现过 createdAt / updatedAt，
    以后即使给 queryParams.value 整体换对象，Vue 的响应式系统依旧能感知到“旧值 → undefined”，DatePicker 就会清空。
    如果 从头到尾没声明过 这两个字段，换对象时路径断裂，DatePicker 收不到变动，就“清不了”。

所以“抽象”的感觉只是 字段有没有被声明 的差异，行为并不魔幻。