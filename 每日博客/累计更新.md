

按 URL 路径控制
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/public/**").permitAll()       // 公开访问
    .requestMatchers("/user/**").hasRole("USER")     // 需 USER 角色
    .requestMatchers("/admin/**").hasRole("ADMIN")   // 需 ADMIN 角色
    .anyRequest().authenticated()                    // 其他请求需登录
);

按 HTTP 方法控制
http.authorizeHttpRequests(auth -> auth
    .requestMatchers(HttpMethod.GET, "/api/read").permitAll()   // 允许 GET
    .requestMatchers(HttpMethod.POST, "/api/write").hasRole("EDITOR")  // 需 EDITOR 角色
);

```mermaid
graph TD
    A[客户端请求] --> B[过滤器链]
    B --> C[Spring Security过滤器]
    C --> D[其他过滤器]
    D --> E[拦截器链]
    E --> F[Spring Security拦截器]
    F --> G[其他拦截器]
    G --> H[Controller]
    H --> I[业务逻辑处理]
    I --> J[异常处理器]
    J --> K[响应客户端]
过滤器属于Servlet容器，其中的异常无法被异常处理器捕获

SecurityContext持久化：Spring Security默认会将认证信息存储在SecurityContextHolder中，而SecurityContextHolder默认使用ThreadLocal存储。但在Web应用中，通常会有SecurityContextPersistenceFilter将SecurityContext存储在Session中，以便在多次请求间保持登录状态。

Session缓存认证：一旦用户成功认证，认证信息会被存储在HttpSession中。后续请求会直接从Session中获取认证信息，而不会每次都执行JWT验证。

------------------------------------

